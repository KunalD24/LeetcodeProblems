#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <limits.h>

#define MAX_LEVEL 16
#define SKIPLIST_P 0.5

typedef struct SkipListNode {
    int key;
    struct SkipListNode **forward;
} SkipListNode;

typedef struct {
    int lvl;
    SkipListNode *header;
} Skiplist;

SkipListNode *createNode(int lvl, int key) {
    SkipListNode *node = (SkipListNode*)malloc(sizeof(SkipListNode));
    node->key = key;
    node->forward = (SkipListNode**)malloc(sizeof(SkipListNode*) * (lvl+1));
    for (int i = 0; i <= lvl; i++) node->forward[i] = NULL;
    return node;
}

Skiplist* skiplistCreate() {
    srand((unsigned)time(NULL));
    Skiplist *list = (Skiplist*)malloc(sizeof(Skiplist));
    list->lvl = 0;
    list->header = createNode(MAX_LEVEL, INT_MIN);
    return list;
}

int randomLevel() {
    int lvl = 0;
    while (((double)rand() / RAND_MAX) < SKIPLIST_P && lvl < MAX_LEVEL) {
        lvl++;
    }
    return lvl;
}

bool skiplistSearch(Skiplist* obj, int target) {
    SkipListNode *cur = obj->header;
    for (int i = obj->lvl; i >= 0; i--) {
        while (cur->forward[i] && cur->forward[i]->key < target) {
            cur = cur->forward[i];
        }
    }
    cur = cur->forward[0];
    return (cur && cur->key == target);
}

void skiplistAdd(Skiplist* obj, int num) {
    SkipListNode *update[MAX_LEVEL+1];
    SkipListNode *cur = obj->header;

    for (int i = obj->lvl; i >= 0; i--) {
        while (cur->forward[i] && cur->forward[i]->key < num) {
            cur = cur->forward[i];
        }
        update[i] = cur;
    }

    cur = cur->forward[0];
    if (!cur || cur->key != num) {
        int lvl = randomLevel();
        if (lvl > obj->lvl) {
            for (int i = obj->lvl + 1; i <= lvl; i++) {
                update[i] = obj->header;
            }
            obj->lvl = lvl;
        }
        SkipListNode *newNode = createNode(lvl, num);
        for (int i = 0; i <= lvl; i++) {
            newNode->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = newNode;
        }
    }
}

bool skiplistErase(Skiplist* obj, int num) {
    SkipListNode *update[MAX_LEVEL+1];
    SkipListNode *cur = obj->header;

    for (int i = obj->lvl; i >= 0; i--) {
        while (cur->forward[i] && cur->forward[i]->key < num) {
            cur = cur->forward[i];
        }
        update[i] = cur;
    }

    cur = cur->forward[0];
    if (cur && cur->key == num) {
        for (int i = 0; i <= obj->lvl; i++) {
            if (update[i]->forward[i] != cur) break;
            update[i]->forward[i] = cur->forward[i];
        }
        free(cur->forward);
        free(cur);
        while (obj->lvl > 0 && obj->header->forward[obj->lvl] == NULL) {
            obj->lvl--;
        }
        return true;
    }
    return false;
}

void skiplistFree(Skiplist* obj) {
    SkipListNode *cur = obj->header->forward[0];
    while (cur) {
        SkipListNode *next = cur->forward[0];
        free(cur->forward);
        free(cur);
        cur = next;
    }
    free(obj->header->forward);
    free(obj->header);
    free(obj);
}
